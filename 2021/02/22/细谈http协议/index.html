<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="HTTP协议(超文本传输协议HyperText Transfer Protocol)，它是基于TCP协议的应用层传输协议，简单来说就是客户端和服务端进行数据传输的一种规则。">
<meta property="og:type" content="article">
<meta property="og:title" content="细谈http协议">
<meta property="og:url" content="http://localhost:4000/2021/02/22/%E7%BB%86%E8%B0%88http%E5%8D%8F%E8%AE%AE/index.html">
<meta property="og:site_name" content="Ivan Shork">
<meta property="og:description" content="HTTP协议(超文本传输协议HyperText Transfer Protocol)，它是基于TCP协议的应用层传输协议，简单来说就是客户端和服务端进行数据传输的一种规则。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://localhost:4000/images/post_img/1f86fc9241e2fb10f313c8fbb6d2faa6_628x344.png">
<meta property="og:image" content="http://localhost:4000/images/post_img/e7d2c17a0af70f8375bb0d8a0f7ceb40_592x333.png">
<meta property="og:image" content="http://localhost:4000/images/post_img/http/d8ed69c6-7c60-4d91-95ff-78628904c35e.png/">
<meta property="og:image" content="http://localhost:4000/images/post_img/http/b920022b-b414-43f0-8caf-2ed92a8b874b.png">
<meta property="og:image" content="http://localhost:4000/images/post_img/http/af957d8e-70c7-41a0-a757-74bbff0c8c4c.png">
<meta property="og:image" content="http://localhost:4000/images/post_img/http/47693d84-0e82-419d-9db5-ca23c33fdf3e.png">
<meta property="og:image" content="http://localhost:4000/images/post_img/http/push1.png">
<meta property="og:image" content="http://localhost:4000/images/post_img/http/push2.png">
<meta property="article:published_time" content="2021-02-22T14:45:23.000Z">
<meta property="article:modified_time" content="2021-02-23T06:43:33.193Z">
<meta property="article:author" content="Ivan">
<meta property="article:tag" content="网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://localhost:4000/images/post_img/1f86fc9241e2fb10f313c8fbb6d2faa6_628x344.png"><title>细谈http协议 | Ivan Shork</title><link ref="canonical" href="http://localhost:4000/2021/02/22/%E7%BB%86%E8%B0%88http%E5%8D%8F%E8%AE%AE/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Tags</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/my-info/"><span class="header-nav-menu-item__icon"><i class="fas fa-info"></i></span><span class="header-nav-menu-item__text">Me</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">细谈http协议</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">创建时间</span><span class="post-meta-item__value">2021-02-22</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新时间</span><span class="post-meta-item__value">2021-02-23</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">5.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时间</span><span class="post-meta-item__value">30m</span></span></div></header><div class="post-body">
        <h1 id="http协议"   >
          <a href="#http协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h1>
      <p>HTTP是基于TCP/IP协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p>

        <h2 id="http请求"   >
          <a href="#http请求" class="heading-link"><i class="fas fa-link"></i></a><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h2>
      <blockquote>
<p>浏览器根据用户输入的URL开启网络请求线程并请求服务器获得资源的过程就叫HTTP请求。</p>
</blockquote>

        <h3 id="请求报文数据格式"   >
          <a href="#请求报文数据格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#请求报文数据格式" class="headerlink" title="请求报文数据格式"></a>请求报文数据格式</h3>
      <p><img src="/images/post_img/1f86fc9241e2fb10f313c8fbb6d2faa6_628x344.png"></p>
<p><strong>请求行:</strong></p>
<ol>
<li> 请求方法，GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。</li>
<li> 请求对应的URL地址，它和报文头的Host属性组成完整的请求URL。</li>
<li> 协议名称及版本号。</li>
</ol>
<p><strong>请求头:</strong></p>
<p>HTTP的报文头，报文头包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。</p>
<p><strong>请求体:</strong></p>
<p>它将一个页面表单中的组件值通过param1=value1&amp;param2=value2的键值对形式编码成一个格式化串，它承载多个请求参数的数据。</p>

        <h2 id="http响应"   >
          <a href="#http响应" class="heading-link"><i class="fas fa-link"></i></a><a href="#http响应" class="headerlink" title="http响应"></a>http响应</h2>
      
        <h3 id="响应报文数据格式"   >
          <a href="#响应报文数据格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#响应报文数据格式" class="headerlink" title="响应报文数据格式"></a>响应报文数据格式</h3>
      <p><img src="/images/post_img/e7d2c17a0af70f8375bb0d8a0f7ceb40_592x333.png"></p>
<p><strong>状态行:</strong></p>
<p>包括协议版本Version、状态码Status Code、回应短语。</p>
<p><strong>响应头:</strong></p>
<p>包括搭建服务器的软件，发送响应的时间，回应数据的格式等信息，</p>
<p><strong>响应正文:</strong></p>
<p>响应的具体数据。</p>

        <h2 id="头部"   >
          <a href="#头部" class="heading-link"><i class="fas fa-link"></i></a><a href="#头部" class="headerlink" title="头部"></a>头部</h2>
      <p>http请求和响应都有相应的头部，它们都是以键值对的方式携带某种信息，或者规定一次请求响应中的行为。除此之外，还有一些首部是通用的。</p>

        <h3 id="通用首部"   >
          <a href="#通用首部" class="heading-link"><i class="fas fa-link"></i></a><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h3>
      <p><img src="/images/post_img/http/d8ed69c6-7c60-4d91-95ff-78628904c35e.png/"></p>

        <h3 id="请求首部"   >
          <a href="#请求首部" class="heading-link"><i class="fas fa-link"></i></a><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h3>
      <p><img src="/images/post_img/http/b920022b-b414-43f0-8caf-2ed92a8b874b.png"></p>

        <h3 id="响应首部"   >
          <a href="#响应首部" class="heading-link"><i class="fas fa-link"></i></a><a href="#响应首部" class="headerlink" title="响应首部"></a>响应首部</h3>
      <p><img src="/images/post_img/http/af957d8e-70c7-41a0-a757-74bbff0c8c4c.png"></p>

        <h3 id="实体首部"   >
          <a href="#实体首部" class="heading-link"><i class="fas fa-link"></i></a><a href="#实体首部" class="headerlink" title="实体首部"></a>实体首部</h3>
      <p><img src="/images/post_img/http/47693d84-0e82-419d-9db5-ca23c33fdf3e.png"></p>

        <h2 id="方法"   >
          <a href="#方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法" class="headerlink" title="方法"></a>方法</h2>
      <p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>

        <h3 id="八种请求方法"   >
          <a href="#八种请求方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#八种请求方法" class="headerlink" title="八种请求方法"></a>八种请求方法</h3>
      <div class="table-container"><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>请求指定的页面信息，并返回实体主体</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源</td>
</tr>
<tr>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td>
</tr>
<tr>
<td>PUT</td>
<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除指定的资源。</td>
</tr>
<tr>
<td>CONNECT</td>
<td>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>用于获取目的资源所支持的通信选项</td>
</tr>
<tr>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
<tr>
<td>PATCH</td>
<td>是对 PUT 方法的补充，用来对已知资源进行局部更新。</td>
</tr>
</tbody></table></div>
<p>下面我们对一些常用的请求进行一些补充。</p>

        <h3 id="HEAD请求"   >
          <a href="#HEAD请求" class="heading-link"><i class="fas fa-link"></i></a><a href="#HEAD请求" class="headerlink" title="HEAD请求"></a>HEAD请求</h3>
      <blockquote>
<p>HEAD方法和GET方法的行为很类似，但是服务器在响应中只返回首部，不会返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查。</p>
</blockquote>
<p>使用HEAD方法有以下优点：</p>
<ul>
<li>  在不获取资源的情况下了解资源的情况（比如：判断其类型)</li>
<li>  通过查看响应的状态码，看看某个对象是否存在</li>
<li>  通过查看首部，测试资源是否被修改</li>
</ul>

        <h3 id="PATCH请求"   >
          <a href="#PATCH请求" class="heading-link"><i class="fas fa-link"></i></a><a href="#PATCH请求" class="headerlink" title="PATCH请求"></a>PATCH请求</h3>
      <p>PUT请求和PATCH请求都是对服务器端的资源进行更新，那么两者有何异同。</p>
<p>举个例子，比如我们要更新一个服务器端资源：一个用户，它的格式如下</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   id: 1,</span><br><span class="line">   name: &#39;ivan&#39;,</span><br><span class="line">   age: 21</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>我们将年龄改为22岁，如果是PUT那么发送的数据是这样的</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id: 1,</span><br><span class="line">    name: &#39;ivan&#39;,</span><br><span class="line">    age: 22</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>
<p>如果是PATCH，那么发送的数据则是这样的</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    age: 22</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>
<p>由此我们可以看出，PUT是对旧资源的全部覆盖来达到更新的效果，而PATCH则是对已知资源的局部更新来达到效果。</p>
<p>在某些情况下如果你觉得用PUT直接覆盖资源会携带很多无用的信息，那么不妨考虑一下PATCH。</p>

        <h3 id="OPTIONS请求"   >
          <a href="#OPTIONS请求" class="heading-link"><i class="fas fa-link"></i></a><a href="#OPTIONS请求" class="headerlink" title="OPTIONS请求"></a>OPTIONS请求</h3>
      <p>我们在平时经常会看到浏览器在发送一次请求之前进行了一次”查询请求”，也叫预见请求，这就是OPTIONS。它是浏览器根据情况给我们加上的，而不是我们自己操作的。</p>

        <h4 id="用途"   >
          <a href="#用途" class="heading-link"><i class="fas fa-link"></i></a><a href="#用途" class="headerlink" title="用途"></a>用途</h4>
      <p>用来检测实际请求能否被服务器接受:</p>
<ul>
<li>  获取服务器支持的HTTP请求方法；</li>
<li>  用来检查服务器的性能。例如：进行跨域请求时的预检，需要向另外一个域名的资源发送一个HTTP OPTIONS请求头，用以判断实际发送的请求是否安全。</li>
</ul>

        <h4 id="什么时候浏览器会给我们加上预检请求？"   >
          <a href="#什么时候浏览器会给我们加上预检请求？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么时候浏览器会给我们加上预检请求？" class="headerlink" title="什么时候浏览器会给我们加上预检请求？"></a>什么时候浏览器会给我们加上预检请求？</h4>
      <p>这里我们就要先说到简单请求和非单请求了，并且联系跨域的场景说明。</p>
<p>我们先来了解两个概念</p>
<p><strong>同源策略</strong>:是浏览器的一种安全策略，目的是为了保证用户信息的安全，防止恶意的网站窃取数据。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。<br>在一个源下去请求和操作另一个源时，协议、域名、端口只要有一个不相同，那么就会被浏览器的同源策略所限制，造成请求失败。</p>
<p><strong>跨域</strong>:那么当我们不同源之间要通信时怎么办，这时候就需要使用跨域手段了，这里我们主要说CORS ,也叫’跨域资源共享’，是一种W3C标准。<br>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。浏览器将CORS跨域请求分为简单请求和非简单请求。</p>
<p><strong>浏览器将CORS跨域请求分为简单请求和非简单请求。</strong></p>
<p>只要同时满足一下两个条件，就属于简单请求:</p>
<ul>
<li>  使用下列方法之一: head, get, post</li>
<li>  请求的头部是Accept, Accept-Language, Content-Language, 并且Content-Type只限于三个值:application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
<p>不同时满足上面的两个条件，就属于非简单请求。浏览器对这两种的处理，是不一样的。</p>
<p>⚠️对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;cors HTTP&#x2F;1.1</span><br><span class="line">Origin: http:&#x2F;&#x2F;api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0...</span><br></pre></td></tr></table></div></figure>
<p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p><strong>CORS请求设置的响应头字段，都以 Access-Control-开头:</strong></p>
<ol>
<li>Access-Control-Allow-Origin：必选<br> 它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</li>
<li>Access-Control-Allow-Credentials：可选<br> 它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</li>
<li>Access-Control-Expose-Headers：可选<br>  CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。    </li>
</ol>
<p>⚠️对于非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>

        <h4 id="预检请求"   >
          <a href="#预检请求" class="heading-link"><i class="fas fa-link"></i></a><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4>
      <p>预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。请求头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，”预检”请求的头信息包括两个特殊字段</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS &#x2F;cors HTTP&#x2F;1.1</span><br><span class="line">Origin: http:&#x2F;&#x2F;api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0..</span><br></pre></td></tr></table></div></figure>
<ol>
<li>Access-Control-Request-Method：必选<br> 用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</li>
<li>Access-Control-Request-Headers：可选<br> 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</li>
</ol>

        <h4 id="预检请求的回应"   >
          <a href="#预检请求的回应" class="heading-link"><i class="fas fa-link"></i></a><a href="#预检请求的回应" class="headerlink" title="预检请求的回应"></a>预检请求的回应</h4>
      <p>服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。</p>
<p>HTTP回应中，除了关键的是Access-Control-Allow-Origin字段，其他CORS相关字段如下：</p>
<ol>
<li>Access-Control-Allow-Methods：必选<br> 它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</li>
<li>Access-Control-Allow-Headers：必选<br> 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</li>
<li>Access-Control-Allow-Credentials：可选<br> 该字段与简单请求时的含义相同。</li>
<li>Access-Control-Max-Age：可选<br> 用来指定本次预检请求的有效期，单位为秒。</li>
</ol>

        <h3 id="POST请求和GET请求的区别"   >
          <a href="#POST请求和GET请求的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#POST请求和GET请求的区别" class="headerlink" title="POST请求和GET请求的区别"></a>POST请求和GET请求的区别</h3>
      <p>POST请求和GET请求是我们日常会经常用到的两个请求方法。</p>
<ol>
<li><p> 在规范的应用场景来说，get多用于无副作用、幂等的场景，而post多用于副作用、不幂等的场景。</p>
<blockquote>
<p><strong>副作用</strong>：是指操作会产生服务端的资源改变，比如注册账号。<br><strong>幂等性</strong>：幂等性用来指客户端发送多次请求，服务端资源的状态一致。譬如对个人信息进行4次更改、5次更改，这是幂等性的，因为只是更新同一个资源。注册4个账号和注册5个账号，这是非幂等性的，因为服务端多了一个资源（账号）</p>
</blockquote>
</li>
<li><p> get可缓存、post不可缓存。</p>
<blockquote>
<p>原因很简单，post一般是会对服务端资源产生影响的请求，而get一般是简单的查询请求，用来做读取功能，读取的数据当然可以进行缓存啦，且不会产生影响。</p>
</blockquote>
</li>
<li><p> post请求相对安全</p>
<blockquote>
<p>Get请求包含在url中且会暴露参数，而Post请求携带的数据则是放在请求体里，并且不会被保存在浏览器历史或服务器日志当中。</p>
</blockquote>
</li>
<li><p> 浏览器url的长度限制会影响get请求，而post请求参数一般没有大小限制</p>
</li>
<li><p> get请求参数是在url里，而post请求是在request.body里。</p>
</li>
<li><p> get请求可以保存在浏览器的历史中，而post请求则不会。</p>
</li>
<li><p> get请求的参数只能是ASCII字符，而post请求则没有限制。</p>
</li>
</ol>
<hr>
<p>上面一大堆的区别，其实本质上是因为HTTP的规定以及浏览器和服务端的交互场景所造成的。<strong>实际上，从http的底层来看，两个请求的本质是一样的，都是一次tcp链接，因为本身http的底层是TCP/IP。</strong></p>
<p>我们把tcp链接想象成运输货物（数据）的车，那么由于安全性、便利性等问题，http应用层这个大佬就给这些车贴上不同的标签：get、post、put、delete等。</p>
<p>根据这些标签对各种类型的车实行不同的规定，比如get请求的车要把参数放在车的顶部（url），这样以便记录，可以缓存起来，而post请求的车则要把参数放在车厢里面（请求体），等等的规则。</p>
<p>因此get和post其实本质上并无区别。当然，两者有一个比较特殊的区别就是：<strong>get请求只发送一个tcp数据包，而post请求则发送两个tcp数据包。</strong></p>
<p>post请求在真正发送数据之前，会先将请求头（header）发送给服务端进行确认，等到服务器响应 100 continue后再发送真正的数据，而get请求则是请求头和数据一起发送。</p>
<p>因此，在一次运输过程中，post得跑两趟，get只需要跑一趟，所以通常情况下post是比get慢的。</p>

        <h1 id="Http的演变"   >
          <a href="#Http的演变" class="heading-link"><i class="fas fa-link"></i></a><a href="#Http的演变" class="headerlink" title="Http的演变"></a>Http的演变</h1>
      
        <h2 id="Http-1-1"   >
          <a href="#Http-1-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#Http-1-1" class="headerlink" title="Http/1.1"></a>Http/1.1</h2>
      <p>HTTP/1.0 版的主要缺点是，<strong>每个TCP连接只能发送一个请求</strong>。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接<br>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（慢启动）。</p>

        <h3 id="持久化连接"   >
          <a href="#持久化连接" class="heading-link"><i class="fas fa-link"></i></a><a href="#持久化连接" class="headerlink" title="持久化连接"></a>持久化连接</h3>
      <blockquote>
<p>即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。</p>
</blockquote>
<p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接</p>

        <h3 id="管道机制"   >
          <a href="#管道机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h3>
      <blockquote>
<p>即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率（以前是一个请求发出收到响应后，再进行下一个请求）</p>
</blockquote>
<p>虽然1.1版本允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。</p>
<p>解决这个方法有以下途径：<strong>一是减少HTTP请求数，二是同时多开TCP持久连接。</strong>这引出了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码，域名分片（domain sharding）等等。</p>

        <h2 id="Http-2"   >
          <a href="#Http-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#Http-2" class="headerlink" title="Http/2"></a>Http/2</h2>
      <blockquote>
<p>HTTP/2主要是为了解决现HTTP 1.1性能不好的问题才出现的。当初Google为了提高HTTP性能，做出了SPDY，它就是HTTP/2的前身，后来也发展成为HTTP/2的标准。</p>
</blockquote>
<ul>
<li>  HTTP/2 相比于 HTTP/1，可以说是大幅度提高了网页的性能。</li>
<li>  在 HTTP/1 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量（Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</li>
<li>  在 HTTP/2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。</li>
</ul>

        <h3 id="二进制分帧"   >
          <a href="#二进制分帧" class="heading-link"><i class="fas fa-link"></i></a><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3>
      <p><strong>帧</strong>:HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。<br><strong>流</strong>:存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID。一个流是由多个帧组成的，每个帧都有对应的标识，表明它们属于哪个流。</p>
<blockquote>
<p>HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。</p>
</blockquote>
<p>在HTTP / 1 中，请求和响应报文，都是由请求行、请求头、请求体以文本换行符分割组成起来的。而在HTTP/2 中，将请求和响应数据分割为更小的帧，并且它们采用二进制编码。</p>

        <h3 id="多路复用"   >
          <a href="#多路复用" class="heading-link"><i class="fas fa-link"></i></a><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3>
      <p>多路复用，代替原来的序列和阻塞机制。所有就是请求的都是通过一个TCP连接并发完成。 HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。</p>
<p>HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。<strong>多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。</strong></p>

        <h3 id="header压缩"   >
          <a href="#header压缩" class="heading-link"><i class="fas fa-link"></i></a><a href="#header压缩" class="headerlink" title="header压缩"></a>header压缩</h3>
      <p>在 HTTP/1 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。</p>
<p>在 HTTP /2 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。</p>

        <h3 id="服务端推送（push）"   >
          <a href="#服务端推送（push）" class="heading-link"><i class="fas fa-link"></i></a><a href="#服务端推送（push）" class="headerlink" title="服务端推送（push）"></a>服务端推送（push）</h3>
      <p>我们在访问网页通常的情况是，发送请求访问到站点的index.html，在解析页面的时候，遇到对应的资源（如css、js）再发起请求再响应。这样一来一回实际上多了几次请求，明明资源是固定的，为何不在一开始就把所有首页加载所用到的资源一并推送给客户端。</p>
<p>因而在这一点的前提下，HTTP /2就做了优化。服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。</p>
<p>服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。</p>
<p><img src="/images/post_img/http/push1.png"></p>
<p><img src="/images/post_img/http/push2.png" alt="服务端推送"></p>

        <h1 id="HTTPS"   >
          <a href="#HTTPS" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTTPS" class="headerlink" title="HTTPS ?"></a>HTTPS ?</h1>
      
        <h2 id="HTTP-和-HTTPS-的区别"   >
          <a href="#HTTP-和-HTTPS-的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTTP-和-HTTPS-的区别" class="headerlink" title="HTTP 和 HTTPS 的区别"></a>HTTP 和 HTTPS 的区别</h2>
      <p>HTTP（Hyper Text Transfer Protocol，超文本传输协议）<br>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer，安全套接字超文本传输协议）</p>
<p>HTTPS在HTTP的基础上加入了<strong>SSL/TLS</strong>，依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>

        <h2 id="特点"   >
          <a href="#特点" class="heading-link"><i class="fas fa-link"></i></a><a href="#特点" class="headerlink" title="特点"></a>特点</h2>
      <ul>
<li>  内容加密：采用混合加密技术，中间者无法直接查看明文内容</li>
<li>  验证身份：通过证书认证客户端访问的是自己的服务器</li>
<li>  保护数据完整性：防止传输的内容被中间人冒充或者篡改</li>
</ul>

        <h2 id="缺点"   >
          <a href="#缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2>
      <ul>
<li>  SSL证书需要购买申请，功能越强大的证书费用越高</li>
<li>  SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。</li>
<li>  根据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电。</li>
<li>  HTTPS连接缓存不如HTTP高效，流量成本高。</li>
<li>  HTTPS连接服务器端资源占用高很多，支持访客多的网站需要投入更大的成本。</li>
<li>  HTTPS协议握手阶段比较费时，对网站的响应速度有影响，影响用户体验。比较好的方式是采用分而治之，类似12306网站的主页使用HTTP协议，有关于用户信息等方面使用HTTPS。</li>
</ul>

        <h2 id="如何从HTTP切换到HTTPS"   >
          <a href="#如何从HTTP切换到HTTPS" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何从HTTP切换到HTTPS" class="headerlink" title="如何从HTTP切换到HTTPS"></a>如何从HTTP切换到HTTPS</h2>
      <ol>
<li> 需要将页面中所有的链接（例如js,css,图片等链接）都由http改为https</li>
<li> 一般情况下会建议保留HTTP，所以在切换的时候可以做HTTP和HTTPS的兼容，具体实现方式是：去掉页面连接中的http头部，这样恶意自动匹配HTTP头和HTTPS头。例如：将<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.baidu.com改为//www.baidu.com%E3%80%82%E7%84%B6%E5%90%8E%E5%BD%93%E7%94%A8%E6%88%B7%E4%BB%8Ehttp%E7%9A%84%E5%85%A5%E5%8F%A3%E8%BF%9B%E5%85%A5%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%E6%97%B6%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%B0%B1%E6%98%AFhttp%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%94%A8%E6%88%B7%E6%98%AF%E4%BB%8Ehttps%E7%9A%84%E5%85%A5%E5%8F%A3%E8%BF%9B%E5%85%A5%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%8D%B3%E4%BD%BFhttps%E7%9A%84%E3%80%82" >http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>

        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      <p>总的来说，http协议是网络体系结构中应用层的重要协议。它的特点主要有以下几方面：</p>
<ul>
<li>  简单快速,灵活</li>
<li>  无连接(在http /1.1以前，每进行一次请求后就会断开连接)</li>
<li>  无状态(服务端不会保存客户端状态，需要通过特定的手段，比如用token验证等)</li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ END ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">Author: </span><span class="copyright-author__value"><a href="http://localhost:4000">Ivan</a></span></div><div class="copyright-link"><span class="copyright-link__name">Link: </span><span class="copyright-link__value"><a href="http://localhost:4000/2021/02/22/%E7%BB%86%E8%B0%88http%E5%8D%8F%E8%AE%AE/">http://localhost:4000/2021/02/22/%E7%BB%86%E8%B0%88http%E5%8D%8F%E8%AE%AE/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">Copyright: </span><span class="copyright-notice__value">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> unless stating additionally</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://localhost:4000/tags/%E7%BD%91%E7%BB%9C/">网络</a></span></div><nav class="post-paginator paginator"><div class="paginator-next"><a class="paginator-next__link" href="/2021/02/22/ES6%E5%88%A9%E5%99%A8%E4%B9%8BPromise/"><span class="paginator-prev__text">ES6利器之Promise</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概述</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#http%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.</span> <span class="toc-text">
          http协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E8%AF%B7%E6%B1%82"><span class="toc-number">1.1.</span> <span class="toc-text">
          http请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">
          请求报文数据格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E5%93%8D%E5%BA%94"><span class="toc-number">1.2.</span> <span class="toc-text">
          http响应</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">
          响应报文数据格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B4%E9%83%A8"><span class="toc-number">1.3.</span> <span class="toc-text">
          头部</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">
          通用首部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">
          请求首部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">
          响应首部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">
          实体首部</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">
          方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E7%A7%8D%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">
          八种请求方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HEAD%E8%AF%B7%E6%B1%82"><span class="toc-number">1.4.2.</span> <span class="toc-text">
          HEAD请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PATCH%E8%AF%B7%E6%B1%82"><span class="toc-number">1.4.3.</span> <span class="toc-text">
          PATCH请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OPTIONS%E8%AF%B7%E6%B1%82"><span class="toc-number">1.4.4.</span> <span class="toc-text">
          OPTIONS请求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E9%80%94"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">
          用途</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E7%BB%99%E6%88%91%E4%BB%AC%E5%8A%A0%E4%B8%8A%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">
          什么时候浏览器会给我们加上预检请求？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">
          预检请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82%E7%9A%84%E5%9B%9E%E5%BA%94"><span class="toc-number">1.4.4.4.</span> <span class="toc-text">
          预检请求的回应</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POST%E8%AF%B7%E6%B1%82%E5%92%8CGET%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.5.</span> <span class="toc-text">
          POST请求和GET请求的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Http%E7%9A%84%E6%BC%94%E5%8F%98"><span class="toc-number">2.</span> <span class="toc-text">
          Http的演变</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Http-1-1"><span class="toc-number">2.1.</span> <span class="toc-text">
          Http&#x2F;1.1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.1.1.</span> <span class="toc-text">
          持久化连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.2.</span> <span class="toc-text">
          管道机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Http-2"><span class="toc-number">2.2.</span> <span class="toc-text">
          Http&#x2F;2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7"><span class="toc-number">2.2.1.</span> <span class="toc-text">
          二进制分帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">
          多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#header%E5%8E%8B%E7%BC%A9"><span class="toc-number">2.2.3.</span> <span class="toc-text">
          header压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A8%E9%80%81%EF%BC%88push%EF%BC%89"><span class="toc-number">2.2.4.</span> <span class="toc-text">
          服务端推送（push）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTPS"><span class="toc-number">3.</span> <span class="toc-text">
          HTTPS ?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E5%92%8C-HTTPS-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.</span> <span class="toc-text">
          HTTP 和 HTTPS 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">
          特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">3.3.</span> <span class="toc-text">
          缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8EHTTP%E5%88%87%E6%8D%A2%E5%88%B0HTTPS"><span class="toc-number">3.4.</span> <span class="toc-text">
          如何从HTTP切换到HTTPS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">
          总结</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/author-avatar.jpeg" alt="avatar"></div><p class="sidebar-ov-author__text">因上努力 果上随缘</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">8</div><div class="sidebar-ov-state-item__name">文章</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">3</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">You have read </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Ivan</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v5.3.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>