<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/my_favicon/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/my_favicon/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="我们都知道js是单线程的，不像其他语言如java可以多开线程进行工作，那么在这种情况下，程序一复杂，任务一多时，js是如何高效的处理的呢，并且丝毫不影响用户体验。">
<meta property="og:type" content="article">
<meta property="og:title" content="javascript之事件循环">
<meta property="og:url" content="http://ivan-shork.github.io/2021/02/23/javascript%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/index.html">
<meta property="og:site_name" content="Ivan Shork">
<meta property="og:description" content="我们都知道js是单线程的，不像其他语言如java可以多开线程进行工作，那么在这种情况下，程序一复杂，任务一多时，js是如何高效的处理的呢，并且丝毫不影响用户体验。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://ivan-shork.github.io/images/post_img/event_loop/screenshot.png">
<meta property="og:image" content="http://ivan-shork.github.io/images/post_img/event_loop/169d1a50de61bc54.JPG">
<meta property="og:image" content="http://ivan-shork.github.io/images/post_img/event_loop/screenshot2.png">
<meta property="og:image" content="http://ivan-shork.github.io/images/post_img/event_loop/screenshot3.png">
<meta property="article:published_time" content="2021-02-23T09:55:01.000Z">
<meta property="article:modified_time" content="2021-02-24T14:35:56.826Z">
<meta property="article:author" content="Ivan">
<meta property="article:tag" content="js">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ivan-shork.github.io/images/post_img/event_loop/screenshot.png"><title>javascript之事件循环 | Ivan Shork</title><link ref="canonical" href="http://ivan-shork.github.io/2021/02/23/javascript%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Tags</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/my-info/"><span class="header-nav-menu-item__icon"><i class="fas fa-info"></i></span><span class="header-nav-menu-item__text">Me</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">javascript之事件循环</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">创建时间</span><span class="post-meta-item__value">2021-02-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新时间</span><span class="post-meta-item__value">2021-02-24</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">3.1k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时间</span><span class="post-meta-item__value">18m</span></span></div></header><div class="post-body"><p>我们都知道js是单线程的，不像其他语言如java可以多开线程进行工作，那么在这种情况下，程序一复杂，任务一多时，js是如何高效的处理的呢，并且丝毫不影响用户体验。</p>
<p>这里我们就要来说一下js的事件循环机制(Event Loop)，是js运行的一个重要策略。</p>

        <h1 id="先决概念"   >
          <a href="#先决概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#先决概念" class="headerlink" title="先决概念"></a>先决概念</h1>
      
        <h2 id="进程与线程"   >
          <a href="#进程与线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2>
      <p><strong>进程是操作系统分配资源的最小单位。</strong>__线程是程序执行的最小单位__。</p>
<p><strong>进程就相当于计算机分配给一个程序实例的内存空间，可以理解为一个上下文（环境）</strong>，在这个环境中，<strong>所有线程的资源是互相共享的</strong>。而多线程就相当于一个进程里有多个执行流，可以同时执行不同的任务互不干扰，并且共享同一块进程的资源。</p>
<p>浏览器是多进程多线程的，譬如有浏览器进程（负责管理整个浏览器），渲染进程（每开一个tab页就会新建一个），插件进程，GPU进程（硬件加速），网络进程。</p>
<p>我们可以打开活动监视器（Activity Monitor）来查看浏览器运行的时候新开了什么进程，我这里用的是Chorme。<br><img src="/images/post_img/event_loop/screenshot.png"></p>

        <h3 id="单线程与多线程"   >
          <a href="#单线程与多线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#单线程与多线程" class="headerlink" title="单线程与多线程"></a>单线程与多线程</h3>
      <p>所谓的单线程是指js引擎线程，它是负责解释和执行js代码的，这个线程只有一个，我们也一般称这个线程为主线程，它是运行在浏览器渲染进程里面的。</p>
<p>但是实际上浏览器的渲染进程是多个的：<br>如<strong>js引擎线程</strong>、事件触发线程、定时器触发线程、异步http请求线程、gui渲染线程。</p>

        <h3 id="主线程和其他线程之间的关系"   >
          <a href="#主线程和其他线程之间的关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#主线程和其他线程之间的关系" class="headerlink" title="主线程和其他线程之间的关系"></a>主线程和其他线程之间的关系</h3>
      <p>当执行代码的时候遇到事件、定时器、请求这些线程时，js引擎会把他们交给浏览器的WebAPIs的其他线程去处理，而js引擎则执行后续的任务，这样实际上实现了一个异步非阻塞的过程。（异步、非阻塞，这两个概念前者是对于调用者来说的，后者是对于被调用者来说的，两者都可以表示在等待一件事情的同时可以去做另一件事，而不必一件事做完才去进行下一件事。）</p>

        <h3 id="为什么js是单线程的？"   >
          <a href="#为什么js是单线程的？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么js是单线程的？" class="headerlink" title="为什么js是单线程的？"></a>为什么js是单线程的？</h3>
      <p>由于dom操作、UI动画等一系列的浏览器网页交互，使得JavaScript设计之初就是一门单线程语言。如果是多线程的话，譬如操作dom的时候在同一时间操控一个相同的节点，那么网页势必会一团糟糕。</p>

        <h2 id="内存堆、调用栈、消息队列"   >
          <a href="#内存堆、调用栈、消息队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存堆、调用栈、消息队列" class="headerlink" title="内存堆、调用栈、消息队列"></a>内存堆、调用栈、消息队列</h2>
      <p><strong>内存堆</strong>是浏览器分配的一大块内存区域，用来进行变量赋值、内存分配。</p>
<p><strong>调用栈</strong>是js引擎主线程任务存放的地方，js引擎在调用栈中顺序执行主线程的代码。当代码运行到一个函数时，函数会被压进栈的顶部，当从函数中返回时，函数会从栈顶弹出。我们把每个函数的条目都叫做栈帧。</p>
<pre><code>Ps： 栈帧我们可以理解为函数调用时形成的一个上下文，也就是我们之前章节说的执行上下文。这个帧中包含了函数的参数和变量。每调用一个函数，就会形成一个调用帧，然后根据顺序调用完就弹出。
</code></pre>
<p><strong>消息队列</strong>(任务队列):一般用来存放那些异步任务，当调用栈为空时（或者说时空闲状态时），js引擎会自动去队列中抓取消息，然后放到栈里面去执行。它是一种先入先出的结构，后进的任务会排在队列的末端。</p>
<pre><code>Ps：在此处我们可以把消息队列中的消息，理解为注册异步任务时添加的回调函数。
</code></pre>

        <h2 id="异步"   >
          <a href="#异步" class="heading-link"><i class="fas fa-link"></i></a><a href="#异步" class="headerlink" title="异步"></a>异步</h2>
      <p>在上面说到消息队列时，我们有必要说一下异步，因为消息队列其实就是跟异步任务挂钩的。</p>
<p><strong>为什么需要异步？</strong></p>
<p>js本身是一个同步的语言，因为js就是单线程的。所有的代码只能自上而下一步步执行，并且前一个任务完成后，才能处理下一个任务。<br>那这样的话用户体验不是很糟糕? 一旦遇到耗时的I/O任务时，程序一直等待它的I/O操作的返回结果，这时就在上面卡死了，网页的运行就只能停顿。</p>
<p>因此，想要运行流畅就要实现异步。让程序不用等待一件事情才去做下一件事情，而是把一部分事（I/O操作）交给另一些人先去处理，自己接着往下做其他事。</p>
<p>所以第一种情况就是同步阻塞，而第二种情况就是异步非阻塞。</p>

        <h1 id="如何实现异步？"   >
          <a href="#如何实现异步？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何实现异步？" class="headerlink" title="如何实现异步？"></a>如何实现异步？</h1>
      
        <h2 id="Event-Loop"   >
          <a href="#Event-Loop" class="heading-link"><i class="fas fa-link"></i></a><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2>
      <p>Event Loop就是为了解决js同步这个问题而生的。</p>
<blockquote>
<p>Event Loop是一个程序结构，用于等待和发送消息和事件。</p>
</blockquote>
<p>这里引用阮一峰老师的一个解释:</p>
<blockquote>
<p>简单说，就是在程序中设置两个线程：一个负责程序本身的运行，称为”主线程”；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为”Event Loop线程”（可以译为”消息线程”）。</p>
</blockquote>
<p>我们可以通过一个例子来解释Event Loop在异步过程种的通信作用。</p>
<p>js主线程：我在运行时碰到了一个难搞的家伙（I/O操作），你去通知其他兄弟（其他线程）搞定一下这个任务，我要去忙其他事情了，</p>
<p>Event Loop线程：收到，老大。</p>
<p>主线程去执行其他同步代码，其他线程的异步操作也开始执行…</p>
<p>Event Loop线程：老大，其他兄弟已经帮你搞定这个任务了，它的回调任务已经被我放到了消息队列里面。</p>
<p>js主线程：好的，收到了，等我手头上的事情忙完会去处理它们的，辛苦你了。</p>
<p><img src="/images/post_img/event_loop/169d1a50de61bc54.JPG"></p>
<p>Event Loop 线程就在这个过程中起到一个协调的作用。</p>
<p>⚠️这里的异步过程有两个很重要的要素：就是<strong>注册函数</strong>和<strong>回调函数</strong>。</p>
<p>注册函数即使用来发起异步过程，让相应的线程去处理异步任务，回调函数用来处理结果，其中的参数可能包含I/O操作返回的数据。</p>
<p>例如<code>div.onclick = function()&#123;&#125;</code> 这个异步过程，这里的<strong>onclick</strong>就是注册函数，交由事件线程处理，后面的匿名函数就是回调函数，交由主线程处理。</p>
<p>再比如<code>setTimeout(fn, 1000) </code>这个异步过程，这里的setTimeout定时器是注册函数，交由定时器线程处理，fn是回调函数，交由主线程处理。</p>

        <h2 id="完整的异步过程"   >
          <a href="#完整的异步过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#完整的异步过程" class="headerlink" title="完整的异步过程"></a>完整的异步过程</h2>
      <p>下面通过一个网络请求的例子来看一下完整的异步过程</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;http://xxx.com/api/v1/users&#x27;</span>,&#123;</span><br><span class="line">    method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    body: <span class="built_in">JSON</span>.stringify(data)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></div></figure>
<p>上面是一个post用户的一个网络请求，js执行时的异步过程是这样的：</p>
<ol>
<li> 主线程发起异步请求（注册函数），</li>
<li> 主线程通过event loop线程通知相应的线程，即网络请求线程来完成这个操作。</li>
<li> 网络请求线程去请求服务端，服务端执行完程序返回结果给客户端。</li>
<li> 异步任务完成，相应的回调函数会被event loop线程添加到消息队列中排队。</li>
<li> 主线程执行完同步任务，调用栈空闲，主线程从消息队列中抓取回调函数到调用栈执行。</li>
</ol>

        <h2 id="事件循环"   >
          <a href="#事件循环" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2>
      <p>事件循环其实就是不断重复消息的存放、抓取、运行的动作。</p>
<ul>
<li>  主线程运行同步任务，遇到异步任务交由其他线程处理 </li>
<li>  异步操作完成，回调函数（即消息）被压入消息队列中排队</li>
<li>  一旦调用栈为空，主线程就不断抓取消息队列中的任务，将它压入调用栈中执行。<br>不断重复上述的动作，就是事件循环。</li>
</ul>
<p><img src="/images/post_img/event_loop/screenshot2.png"></p>

        <h2 id="宏任务和微任务"   >
          <a href="#宏任务和微任务" class="heading-link"><i class="fas fa-link"></i></a><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2>
      <p>在挂起任务的时候，js引擎会将这些异步任务分为两类，推入不同的任务队列中，即<strong>宏任务(macro-task)队列</strong>和<strong>微任务(micro-task)队列</strong>。当js引擎执行完主线程的同步任务并且调用栈空闲时时，事件循环会先去取微任务队列中的任务顺序执行，执行完后再去宏任务队列中抓取任务进行执行。</p>
<ul>
<li><p>  宏任务类型: 包括整体代码 script，setTimeout，setIntervcal</p>
</li>
<li><p>  微任务类型: Promise，process.nextTick</p>
</li>
</ul>
<p><img src="/images/post_img/event_loop/screenshot3.png"></p>
<p>⚠️需要注意的是，事件循环中对于宏任务队列和微任务队列的处理情况是不同的。当 macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的。</p>
<p>也就是说，当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的<strong>所有任务</strong>，如果没有，会读取宏任务队列中排在最前的任务。</p>
<p>举个例子：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//执行后 回调一个宏事件</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;内层宏事件3&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;外层宏事件1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;外层宏事件2&#x27;</span>);</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;微事件1&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;微事件2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//result：</span></span><br><span class="line"><span class="comment">//外层宏事件1</span></span><br><span class="line"><span class="comment">//外层宏事件2</span></span><br><span class="line"><span class="comment">//微事件1</span></span><br><span class="line"><span class="comment">//微事件2</span></span><br><span class="line"><span class="comment">//内层宏事件3</span></span><br></pre></td></tr></table></div></figure>
<ul>
<li>  首先浏览器执行js进入第一个宏任务进入主线程, 遇到 setTimeout  分发到宏任务Event Queue中</li>
<li>  遇到 console.log() 直接执行 输出 外层宏事件1</li>
<li>  遇到 Promise， new Promise 直接执行 输出 外层宏事件2</li>
<li>  执行then 被分发到微任务Event Queue中</li>
<li>  第一轮宏任务执行结束，开始执行微任务 打印 ‘微事件1’ ‘微事件2’</li>
<li>  第一轮微任务执行完毕，执行第二轮宏事件，打印setTimeout里面内容’内层宏事件3’</li>
</ul>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程直接执行</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="comment">//丢到宏事件队列中</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//微事件1</span></span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//主线程直接执行</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//微事件2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//丢到宏事件队列中</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//result：</span></span><br><span class="line"><span class="comment">//输出1，7，6，8，2，4，3，5，9，11，10，12。</span></span><br></pre></td></tr></table></div></figure>
<ul>
<li>  首先浏览器执行js进入第一个宏任务进入主线程, 直接打印console.log(‘1’)</li>
<li>  遇到 setTimeout  分发到宏任务Event Queue中</li>
<li>  遇到 process.nextTick 丢到微任务Event Queue中</li>
<li>  遇到 Promise， new Promise 直接执行 输出 console.log(‘7’);</li>
<li>  执行then 被分发到微任务Event Queue中</li>
<li>  第一轮宏任务执行结束，开始执行微任务 打印 6,8</li>
<li>  第一轮微任务执行完毕，执行第二轮宏事件，执行setTimeout</li>
<li>  先执行主线程宏任务，在执行微任务，打印’2,4,3,5’</li>
<li>  在执行第二个setTimeout,同理打印 ‘9,11,10,12’</li>
<li>  整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。</li>
</ul>
<p>到这里，事件循环机制算是讲完了。它是js能够运行流畅的一个重要机制，使得当网页在进行耗时的I/O操作时，不会阻塞其他代码的运行。</p>
<hr>
<p><strong>参考</strong><br><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://juejin.cn/post/6844903512845860872" >这一次，彻底弄懂 JavaScript 执行机制</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ END ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">Author: </span><span class="copyright-author__value"><a href="http://ivan-shork.github.io">Ivan</a></span></div><div class="copyright-link"><span class="copyright-link__name">Link: </span><span class="copyright-link__value"><a href="http://ivan-shork.github.io/2021/02/23/javascript%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">http://ivan-shork.github.io/2021/02/23/javascript%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">Copyright: </span><span class="copyright-notice__value">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> unless stating additionally</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://ivan-shork.github.io/tags/js/">js</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/02/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E4%B9%8Bcomposite/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">浏览器页面渲染之composite</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/02/23/javascript%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"><span class="paginator-prev__text">javascript之执行上下文</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概述</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%88%E5%86%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">
          先决概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">
          进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">
          单线程与多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.2.</span> <span class="toc-text">
          主线程和其他线程之间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88js%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">
          为什么js是单线程的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%A0%86%E3%80%81%E8%B0%83%E7%94%A8%E6%A0%88%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.2.</span> <span class="toc-text">
          内存堆、调用栈、消息队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-number">1.3.</span> <span class="toc-text">
          异步</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">
          如何实现异步？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Event-Loop"><span class="toc-number">2.1.</span> <span class="toc-text">
          Event Loop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%BC%82%E6%AD%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">
          完整的异步过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.3.</span> <span class="toc-text">
          事件循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.4.</span> <span class="toc-text">
          宏任务和微任务</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/author-avatar.jpeg" alt="avatar"></div><p class="sidebar-ov-author__text">因上努力 果上随缘</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">28</div><div class="sidebar-ov-state-item__name">文章</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">8</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">You have read </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Ivan</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v5.3.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>