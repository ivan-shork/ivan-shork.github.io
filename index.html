<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="Ivan Shork">
<meta property="og:url" content="http://localhost:4000/index.html">
<meta property="og:site_name" content="Ivan Shork">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Ivan">
<meta name="twitter:card" content="summary"><title>Ivan Shork</title><link ref="canonical" href="http://localhost:4000/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Tags</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/my-info/"><span class="header-nav-menu-item__icon"><i class="fas fa-info"></i></span><span class="header-nav-menu-item__text">Me</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Ivan Shork</div><div class="header-banner-info__subtitle">seize the day</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><div class="sticky-top" data-popover="Sticky" data-popover-pos="up"><span class="sticky-top__icon"><i class="fas fa-thumbtack"></i></span></div><h1 class="post-title"><a class="post-title__link" href="/2021/02/17/my-firtst-article/">年少可期</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">创建时间</span><span class="post-meta-item__value">2021-02-17</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新时间</span><span class="post-meta-item__value">2021-02-24</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.1k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时间</span><span class="post-meta-item__value">5m</span></span></div></header><div class="post-body"><div class="post-excerpt">人存在这世间总要写下点什么，不一定要给别人看，至少让自己知道，你一直以来的努力和你依附在这上面的力量。 不管是学习还是自己的心路历程，我早已习惯于将它们作为笔记记在电脑上，我也有过自己的公众号用来矫情世间。 但我还是想选择通过一个站点来记录这些东西，这是我一直以来想做的事情，毕竟我也是程序员出身，干这个事情还是比较有意义的。 因此，我会把之前所有的学习笔记和日常思考、感悟等文章搬到这上面来，作为我新的根据地，也作为我2021年的一个开篇。 希望这件事情是可以一直做下去的，坚持输出，坚持总结，坚持反馈。</div><div class="post-readmore"><a class="post-readmore__link" href="/2021/02/17/my-firtst-article/"><span class="post-readmore__text">Read More</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/02/25/Cookie/">Cookie</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">创建时间</span><span class="post-meta-item__value">2021-02-25</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新时间</span><span class="post-meta-item__value">2021-02-25</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.1k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时间</span><span class="post-meta-item__value">6m</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息。</p>
<p>说白了，就是客户端保存的一个简单的文本文件，一般大小不超过4kb。</p>

        <h1 id="Cookie的处理"   >
          <a href="#Cookie的处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#Cookie的处理" class="headerlink" title="Cookie的处理"></a>Cookie的处理</h1>
      <ul>
<li>服务器向客户端发送cookie</li>
<li>浏览器将cookie持久化在本地保存</li>
<li>之后每次http请求浏览器都会将cookie（请求头中携带）发送给服务器端，服务器端接受到cookie后就可以辨别用户的身份，或者通过里面的jsessionid来知道跟踪对应的session。</li>
</ul>

        <h1 id="服务端发送Cookie"   >
          <a href="#服务端发送Cookie" class="heading-link"><i class="fas fa-link"></i></a><a href="#服务端发送Cookie" class="headerlink" title="服务端发送Cookie"></a>服务端发送Cookie</h1>
      <p>服务器端发送cookie是通过响应报文实现的，在Set-Cookie中设置需要像客户端发送的cookie，cookie格式如下：</p>
<pre><code>Set-Cookie: &quot;name=value;domain=.domain.com;path=/;expires=Sat, 11 Jun 2016 11:29:42 GMT;HttpOnly;secure&quot;
</code></pre>
<ul>
<li>name:一个唯一确定的cookie名称。通常来讲cookie的名称是不区分大小写的。</li>
<li>value:存储在cookie中的字符串值。最好为cookie的name和value进行url编码。</li>
<li>domain:cookie对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie信息。这个值可以包含子域(如：yq.aliyun.com)，也可以不包含它(如：.aliyun.com，则对于aliyun.com的所有子域都有效).</li>
<li>path: 表示这个cookie影响到的路径，浏览器跟会根据这项配置，像指定域中匹配的路径发送cookie。</li>
<li>expires:失效时间，表示cookie何时应该被删除的时间戳(也就是，何时应该停止向服务器发送这个cookie)。如果不设置这个时间戳，浏览器会在页面关闭时即将删除所有cookie；不过也可以自己设置删除时间。这个值是GMT时间格式，如果客户端和服务器端时间不一致，使用expires就会存在偏差。</li>
<li>max-age: 与expires作用相同，用来告诉浏览器此cookie多久过期（单位是秒），而不是一个固定的时间点。正常情况下，max-age的优先级高于expires。</li>
<li>HttpOnly: 告知浏览器不允许通过js脚本（document.cookie）去读写cookie的值。这对防止某些跨站点脚本的攻击(XSS)非常有用。但在http请求中仍然会携带这个cookie。注意这个值虽然在脚本中不可获取，但仍然在浏览器安装目录中以文件形式存在。这项设置通常在服务器端设置。</li>
<li>secure: 安全标志，指定后，只有在使用SSL链接时候才能发送到服务器，如果是http链接则不会传递该信息。就算设置了secure 属性也并不代表他人不能看到你机器本地保存的 cookie 信息，所以不要把重要信息放cookie就对了服务器端设置</li>
</ul>

        <h1 id="Cookie是如何工作的"   >
          <a href="#Cookie是如何工作的" class="heading-link"><i class="fas fa-link"></i></a><a href="#Cookie是如何工作的" class="headerlink" title="Cookie是如何工作的"></a>Cookie是如何工作的</h1>
      <p>存储cookie是浏览器提供的功能。cookie 其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 cookie 文件夹来存放各个域下设置的cookie。</p>
<p>当网页要发http请求时，浏览器会先检查是否有相应的cookie，有则自动添加在request header中的cookie字段中。这些是浏览器自动帮我们做的，而且每一次http请求浏览器都会自动帮我们做。</p>
<p>存储在cookie中的数据，每次都会被浏览器自动放在http请求中，如果这些数据并不是每个请求都需要发给服务端的数据，</p>
<p><strong>因此Cookie用来存放身份认证的信息最适合不过了，其他的则不太适合。</strong></p>

        <h1 id="Cookie的设置"   >
          <a href="#Cookie的设置" class="heading-link"><i class="fas fa-link"></i></a><a href="#Cookie的设置" class="headerlink" title="Cookie的设置"></a>Cookie的设置</h1>
      <p>cookie的设置可以在服务器端设置也可以在客户端设置。</p>
<p>服务器端：<br>服务器端设置就通过set-cookie字段来设置就可以。</p>
<p>客户端：<br>客户端设置可以通过document.cookie来设置，且不是所有属性都可以设置，比如HttpOnly。<br>document.cookie = “name=Jonh”;</p>
<p>修改cookie：<br>只要覆盖旧值就行了，但同样要注意，path/domain/这几个选项一定要旧cookie 保持一样。否则会添加一个新的cookie。</p>
<p>删除cookie：<br>只需要设置cookie的expires为一个过去的时间节点就行了，但同样要注意，path/domain/这几个选项一定要旧cookie 保持一样。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/02/25/%E4%BB%B7%E5%80%BC%E8%A7%82/">价值观</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">创建时间</span><span class="post-meta-item__value">2021-02-25</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新时间</span><span class="post-meta-item__value">2021-02-25</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">624</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时间</span><span class="post-meta-item__value">3m</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>晨起间看到朋友圈发的“除了生病以外，你所感受到的痛苦都是你的价值观带来的，而非真实存在”。</p>
<p>这让我联想到冥想曾接触过的一句话：“想法是想法， 而你， 是你”</p>
<p><strong>价值观—&gt;思维方式—&gt;行为—&gt;行为受阻—&gt;思想苦恼—&gt;产生情绪—&gt;情绪带来痛苦</strong></p>
<p>但受自身的局限，很多情况下我们没法跳出这份痛苦，以旁观者的身份看到那份痛苦背后的思想以及价值观。</p>
<p>价值观是经由你生下来所在的原生家庭、外界的环境、个人的行为发展不断交互形成的。你的第一次普世价值观的形成可以说就是在原生家庭成长这个阶段所形成。</p>
<p>所以我不经在想，我的价值观是什么？</p>
<p>想了很久，大概是完美地完成别人交付自己的任务，不辜负别人对自己的期待，完美地活在他人的眼中。</p>
<p>这是我从出生到现在，目前为止的价值观，有局限，但不可否认的是也激励了我的成长，使我变成现在这样一个人。</p>
<p>这个价值观就像一个孩子一样在我心底不断长大到现在，已有十几年之久。</p>
<p>如果想要让这个孩子换一种人生活法，换一种思考方式，基本上是很难做到的。</p>
<p>但我可以抱持他的情绪、抱持他的痛苦，每次当他的思想受阻所带来的烦恼时，我都可以理性地看到他背后的本质，那份不断要求自己、那份渴望他人理解、那份期待他人拥抱的柔软的心。</p>
<p>只要我拥抱他，我才能慢慢融化他，改变他，告诉他，其实我们可以换一种活法，我们可以做真正的我们。</p>
<p><strong>“一个人如果没办法与自己和解，那他是很难做到自我革新的”</strong></p>
<p>与自己和解，说到底就是与自己一路以来形成的价值观和解。首先拥抱这个价值观，接受它好与不好的两面，再慢慢地强化它好的一面，淡化它坏的一面。</p>
<p>永远温柔地对待内心那个孩子，就像父亲母亲照顾孩子一样，不必过多苛责，不必言传身教，只是陪伴，引导。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/02/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E4%B9%8Bcomposite/">浏览器页面渲染之composite</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">创建时间</span><span class="post-meta-item__value">2021-02-25</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新时间</span><span class="post-meta-item__value">2021-02-25</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.2k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时间</span><span class="post-meta-item__value">7m</span></span></div></header><div class="post-body"><div class="post-excerpt">浏览器在渲染这个过程中对图层的处理，特别是图层的合并。这是浏览器在渲染前最重要的一步工作，并且关系到GPU，也就是我们常说的图形处理器的利用。了解这一步骤，这对于渲染性能的优化是十分有用的。</div><div class="post-readmore"><a class="post-readmore__link" href="/2021/02/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E4%B9%8Bcomposite/"><span class="post-readmore__text">Read More</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/02/23/javascript%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">javascript之事件循环</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">创建时间</span><span class="post-meta-item__value">2021-02-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新时间</span><span class="post-meta-item__value">2021-02-24</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">3.1k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时间</span><span class="post-meta-item__value">18m</span></span></div></header><div class="post-body"><div class="post-excerpt">我们都知道js是单线程的，不像其他语言如java可以多开线程进行工作，那么在这种情况下，程序一复杂，任务一多时，js是如何高效的处理的呢，并且丝毫不影响用户体验。</div><div class="post-readmore"><a class="post-readmore__link" href="/2021/02/23/javascript%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"><span class="post-readmore__text">Read More</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/02/23/javascript%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/">javascript之执行上下文</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">创建时间</span><span class="post-meta-item__value">2021-02-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新时间</span><span class="post-meta-item__value">2021-02-24</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.5k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时间</span><span class="post-meta-item__value">8m</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>js引擎是单线程的，在运行脚本时我们可以想象有一条执行流从上到下流经各个代码区块的时候，在各个区块会创建出相应的执行环境，这种环境就叫执行上下文。</p>
<p>所谓的代码区块是指什么呢，指的是js的三个运行环境，其中包括</p>
<ul>
<li>  全局环境：这是js最先进入的执行环境。</li>
<li>  函数环境：函数被调用的时候，会创建相应的函数执行环境</li>
<li>  eval</li>
</ul>
<p>那么，一个代码区块里可能嵌套着多个函数，从而产生多个执行环境，这么多执行环境（上下文），js是怎么管理它们的呢？</p>
<p>这里就要引入一个执行上下文栈的概念。</p>

        <h2 id="执行上下文栈"   >
          <a href="#执行上下文栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2>
      <p>它是一个基本的栈结构，遵循”先进后出”的原则，每当产生一个执行上下文，js引擎就会将它们压入栈底。当代码执行完毕，它又会从栈中弹出，等待销毁。js的运行过程就是执行上下文在不断创建、运行、销毁的过程。</p>
<p>栈底永远是全局执行上下文，因为它是执行流最先流经的区块，<strong>我们可以把它想象成一个全局兜底的环境，里面包含着其他函数运行时产生的环境</strong>。只有当全部函数执行上下文销毁并且全局代码执行完毕时，它才会从栈底弹出。</p>
<p>因此，当浏览器窗口关闭后，全局执行上下文才会出栈。至此，一个javascript程序运行终结。</p>
<p>我们可以通过以下代码来看看执行上下文栈的工作过程</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></div></figure>
<ul>
<li><p>  首先，程序开始运行，运行前会先进行编译（在js引擎工作原理一章有讲过），然后再执行，此时会创建全局执行上下文，并将它压入栈底。<br><img src="/images/post_img/scope/screenshot.png"></p>
</li>
<li><p>  接着，全局执行上下文其中的可执行代码执行，遇到foo()，此时激活foo创建函数执行上下文，foo执行上下文入栈。</p>
</li>
</ul>
<p><img src="/images/post_img/scope/screenshot2.png"></p>
<ul>
<li><p>  foo执行上下文可执行代码执行，紧接着遇到bar()，创建bar执行上下文并将它入栈。<br><img src="/images/post_img/scope/screenshot3.png"></p>
</li>
<li><p>  bar上下文可执行代码执行完成，没有遇到要继续创建执行上下文的代码，bar执行上下文从栈中弹出并等待销毁。<br><img src="/images/post_img/scope/screenshot2.png"></p>
</li>
<li><p>  foo执行上下文可执行代码完成，foo执行上下文出栈。<br><img src="/images/post_img/scope/screenshot.png"></p>
</li>
<li><p>  全局执行上下文在浏览器窗口关闭后出栈。</p>
</li>
</ul>

        <h2 id="执行上下文的生命周期"   >
          <a href="#执行上下文的生命周期" class="heading-link"><i class="fas fa-link"></i></a><a href="#执行上下文的生命周期" class="headerlink" title="执行上下文的生命周期"></a>执行上下文的生命周期</h2>
      <p>js执行流流经代码区块的运行过程，就是执行上下文反复创建、执行、销毁的过程。</p>
<p>因此执行上下文的生命周期就是：<strong>创建、执行、销毁</strong>。</p>
<p><img src="/images/post_img/scope/4067575-42d6c06ba1f19f3e.png"></p>
<ul>
<li><p>创建阶段</p>
<ul>
<li>  生成变量对象(函数里的叫活动对象)</li>
<li>  建立作用域链</li>
<li>确定 this 指向</li>
</ul>
</li>
<li><p>执行阶段</p>
<ul>
<li>  变量赋值</li>
<li>  函数引用</li>
<li>  执行其他代码</li>
</ul>
</li>
<li><p>销毁阶段</p>
<ul>
<li>  执行完毕出栈，等待回收被销毁</li>
</ul>
</li>
</ul>
<p>__变量对象__：<br>这里的变量对象是一个很重要的概念，你可以把它理解为执行上下文里作用域的一个实体。执行上下文里定义的变量、函数都保存在这个对象中。</p>
<p>它在执行上下文创建的阶段就立马初始化，<strong>并且会在稍后压入作用域链的顶端构造该执行上下文的最终作用域链</strong>。</p>
<p>变量对象的初始化分下面三个阶段：</p>
<ul>
<li>  扫描当前执行上下文中的所有形参（针对函数执行上下文）：该过程生成 Arguments 对象，并创建以形参变量名作为属性名，形参变量值作为属性值的变量对象属性；我们都知道，在函数中，有一个 arguments 对象，存储了所有传递给函数的参数，那么这个对象是哪里来的呢，其实它就是在这个阶段生成的。</li>
<li>  扫描当前执行上下文中的所有函数声明：该过程创建以函数名作为属性名，函数的引用地址作为属性值的变量对象属性；</li>
<li>  扫描当前执行上下文中的所有变量声明：该过程创建以变量名作为属性名，undefined 作为属性值的变量对象属性；（变量的赋值是在代码执行阶段进行的）</li>
</ul>
<p>在第二三阶段其实就涉及到我们平时常说的函数声明提升和变量提升，并且函数声明提升的优先级是高于变量声明提升的。<strong>如果变量声明和函数声明有冲突的话，变量对象初始化时会忽略前者。</strong></p>
<p>这里举个变量对象初始化的小例子:</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="string">&#x27;ivan&#x27;</span>)</span><br></pre></td></tr></table></div></figure>
<p>这里调用foo，创建执行上下文时会创建以下一个变量对象(活动对象)</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: &#39;ivan&#39;</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    name: &#39;ivan&#39;,</span><br><span class="line">    a: undefined,</span><br><span class="line">    bar: reference to function bar()&#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>然后执行可执行代码，进入执行阶段，修改变量对象的值。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: &#39;ivan&#39;</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    name: &#39;ivan&#39;,</span><br><span class="line">    a: 1,</span><br><span class="line">    bar: reference to function bar()&#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><strong>全局上下文的变量对象</strong></p>
<p>在浏览器中，全局对象为window。</p>
<p>全局上下文有一个特殊的地方，它的变量对象，就是window对象。而这个特殊，在this指向上也同样适用，this也是指向window。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局上下文</span><br><span class="line">windowEC &#x3D; &#123;</span><br><span class="line">    VO: window,  &#x2F;&#x2F;变量对象</span><br><span class="line">    scopeChain: &#123;&#125;, &#x2F;&#x2F;作用域链</span><br><span class="line">    this: window    &#x2F;&#x2F;this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>全局上下文的生命周期在程序运行时一直存在，只要不关闭浏览器，全局上下文就一直存在，并且其变量对象可以作为兜底对象被其他上下文使用。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/02/23/javascript%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F/">javascript之作用域</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">创建时间</span><span class="post-meta-item__value">2021-02-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新时间</span><span class="post-meta-item__value">2021-02-24</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时间</span><span class="post-meta-item__value">8m</span></span></div></header><div class="post-body"><div class="post-excerpt"><blockquote>
<p>作用域在我们<a href="http://localhost:4000/2021/02/20/js%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">js引擎工作原理</a>一章中有讲到，它是js引擎的两大帮手之一，<br><strong>负责确定当前执行代码对标识符的访问权限</strong>并且告诉js引擎标识符在哪里并且如何引用它们。本节我们详细谈谈这个js运行的重要角色。</p>
</blockquote>

        <h1 id="js的作用域"   >
          <a href="#js的作用域" class="heading-link"><i class="fas fa-link"></i></a><a href="#js的作用域" class="headerlink" title="js的作用域"></a>js的作用域</h1>
      <p><strong>作用域确定了代码中某些区块变量、函数等的可访问性。</strong></p>
<p>我们都知道js是解释型语言，在执行前会先解释代码，作用域规则就是在这个阶段确定的。<br>因此作用域是在函数声明的时候就定义的，而不是运行时。它相当于一个空间，把各个区块的变量隔绝起来，不会泄漏出去。</p>

        <h2 id="静态作用域和动态作用域？"   >
          <a href="#静态作用域和动态作用域？" class="heading-link"><i class="fas fa-link"></i></a><a href="#静态作用域和动态作用域？" class="headerlink" title="静态作用域和动态作用域？"></a>静态作用域和动态作用域？</h2>
      <p>js采用的是静态作用域（词法作用域）。函数的作用域在函数声明或定义的时候就确定了，相反动态作用域是在函数调用的时候才确定的。</p>
<p>让我们来看一个经典的例子：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">    inner()</span><br><span class="line">&#125;</span><br><span class="line">outer() <span class="comment">// 1</span></span><br></pre></td></tr></table></div></figure>
<p>上面函数的执行结果是1，从这我们就可以得到js采用的是静态作用域。</p>
<ul>
<li>  运行inner()函数</li>
<li>  发现inner函数里面并没有a变量</li>
<li>  从inner函数的书写位置查找上一层作用域是否存在a</li>
<li>  找到，返回1</li>
</ul>
<p>它是从书写的位置（也就是定义的时候）确定的，而非执行调用的时候。</p>
<p>同样来看一个闭包的例子</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(a)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> func = outer()</span><br><span class="line">func()</span><br></pre></td></tr></table></div></figure>
<p>outer函数执行完后，即使词法作用域在表面看起来已经被销毁，且函数在词法作用域之外执行。</p>
<p>但是函数能够记住这个定义时的词法作用域并在使用时访问到它，所以这里仍然输出1，而不是全局词法作用域的2。</p>

        <h2 id="作用域链"   >
          <a href="#作用域链" class="heading-link"><i class="fas fa-link"></i></a><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2>
      <p>当查找变量的时候，会先从当前执行上下文的变量对象中查找，如果没有找到，就会从父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。<br>这里执行上下文和变量对象的概念在<a href="http://localhost:4000/2021/02/20/javascript%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87">javascript之执行上下文</a>中有提及。</p>
<p>下面，让我们以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。</p>

        <h3 id="函数定义时的-Scopes"   >
          <a href="#函数定义时的-Scopes" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数定义时的-Scopes" class="headerlink" title="函数定义时的[[Scopes]]"></a>函数定义时的[[Scopes]]</h3>
      <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="number">3</span></span><br><span class="line">        <span class="built_in">console</span>.log(b, name)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>在函数定义的时候，函数会有一个内部属性[[Scopes]]:它保存的是所有父级的变量对象。</p>
<p>它是一个类似作用域链的层级链，但不是完整的作用域链。</p>
<p>从上面的代码看，outer函数的[[Scopes]]应该是全局执行上下文的变量对象</p>
<p>inner函数的[[Scopes]]是outer函数执行上下文的活动对象+全局执行上下文的变量对象。</p>
<p>我们可以通过以下代码来看到其中的奥妙。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(outer)</span><br><span class="line"><span class="built_in">console</span>.dir(outer(<span class="string">&#x27;ivan&#x27;</span>))</span><br></pre></td></tr></table></div></figure>
<p>我们首先来看看outer的[[Scopes]]属性：<br><img src="/images/post_img/scope/8abfa3e3-ef36-4835-92e6-b671b7bfbf43.png"><br><img src="/images/post_img/scope/41aae554-5938-4f3e-a9de-acd2ef61822d.png"><br>里面包含了全局执行上下文的变量对象，并且可以看到a的值为1。</p>
<p>接着来看看inner的[[Scopes]]属性：<br><img src="/images/post_img/scope/a5e214ec-3490-45c6-946d-9c4d2930307a.png"><br><img src="/images/post_img/scope/c4d19171-ddd4-4706-a639-c24a417fb609.png"><br>里面包含了outer函数执行上下文的活动对象+全局执行上下文的变量对象，并且可以看到outer函数活动对象的参数name和变量b，全局变量对象的a。</p>
<p>所以我们不难理解，函数创建时内部的[[Scopes]]是这样的：（AO为活动对象，VO为变量对象）</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">outer.[[scope]] &#x3D; [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">inner.[[scope]] &#x3D; [</span><br><span class="line">    outerContext.AO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></div></figure>
<p>接着最重要的一步来了！</p>
<p>当函数执行调用的时候，函数的执行上下文被压入执行上下文栈，VO创建完毕，此时该函数执行上下文的作用域链才确定，为:[[Scopes]] + AO。</p>

        <h3 id="作用域链的形成过程"   >
          <a href="#作用域链的形成过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#作用域链的形成过程" class="headerlink" title="作用域链的形成过程"></a>作用域链的形成过程</h3>
      <p>我们来模仿一下一个函数的整个作用域链形成的一个过程：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></div></figure>
<p>1.定义函数foo，foo的内部属性[[Scopes]]初始化形成</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo.[[scope]] &#x3D; [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></div></figure>
<p>2.执行foo函数，创建foo执行上下文，并将其压入执行上下文栈内</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ECStack &#x3D; [</span><br><span class="line">    fooContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>3.foo函数此时还不立即执行，而是复制其内部的[[Scopes]]属性创建作用域链</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fooContext &#x3D; &#123;</span><br><span class="line">    Scope: foo.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>4.初始化自己的活动对象AO,通过arguments对象，形参：name，函数声明：此处无，变量声明：b 初始化活动对象。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fooContext &#x3D; &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            0: undefined</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        name: &#39;ivan&#39;</span><br><span class="line">        b: undefined</span><br><span class="line">    &#125;，</span><br><span class="line">    Scope: foo.[[Scopes]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>5.将活动对象压入foo作用域链的顶端</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fooContext &#x3D; &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            0: &#39;ivan&#39;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        name: &#39;ivan&#39;</span><br><span class="line">        b: undefined</span><br><span class="line">    &#125;，</span><br><span class="line">    Scope: [AO, [[Scope]]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>6.准备工作完成，foo函数真正执行，此时修改AO的值</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fooContext &#x3D; &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            0: &#39;ivan&#39;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        name: &#39;ivan&#39;</span><br><span class="line">        b: 2</span><br><span class="line">    &#125;，</span><br><span class="line">    Scope: [AO, [[Scope]]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>7.对b进行RHS引用，查找到值后返回，函数执行上下文从执行上下文栈弹出。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack &#x3D; [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>



</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/02/23/javascript%E4%B9%8BGC/">javascript之GC</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">创建时间</span><span class="post-meta-item__value">2021-02-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新时间</span><span class="post-meta-item__value">2021-02-25</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">2k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时间</span><span class="post-meta-item__value">11m</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>我们在生活中都明白一个道理，东西用久了不再用了，扔到垃圾桶里面就成了垃圾，这个过程需要我们手动去收集这些垃圾。但在javascript中，垃圾的回收是系统自动帮我们做的，那么当不再需要某些东西时，js是如何回收它们的呢？这一章我们就要来谈一谈js的垃圾回收机制。</p>

        <h1 id="内存管理"   >
          <a href="#内存管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1>
      <p>提到垃圾回收，我们首先不得不谈内存管理。因为程序执行时所有的东西(js中的基本类型、引用类型)都是存储在内存中的，当它们不再需要使用的时候，js再从内存中释放并清空它们。</p>
<blockquote>
<p>JavaScript 中的内存管理是自动执行的，而且是不可见的。</p>
</blockquote>
<p><strong>内存生命周期</strong>主要包括以下三个阶段：</p>
<ul>
<li>分配所需要的内存  <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>; <span class="comment">// 给数值变量分配内存</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;ivan&quot;</span>; <span class="comment">// 给字符串分配内存</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">&#125;; <span class="comment">// 给对象及其包含的值分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给数组及其包含的值分配内存(也是对象)</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">&quot;ivan&quot;</span>]; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">2</span>;</span><br><span class="line">&#125; <span class="comment">// 给函数（可调用的对象）分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式也能分配一个对象</span></span><br><span class="line">someElement.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  someElement.style.backgroundColor = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></li>
<li>使用分配的内存(对变量进行操作)  对变量进行操作包括对变量进行读取与写入甚至传递函数的参数。  <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取n变量</span></span><br><span class="line"><span class="built_in">console</span>.log(n)</span><br><span class="line"><span class="comment">// 为obj对象添加属性</span></span><br><span class="line">obj.name = <span class="string">&#x27;ivan&#x27;</span></span><br><span class="line"><span class="comment">// 调用func这个函数引用</span></span><br><span class="line">func(<span class="string">&#x27;ivan&#x27;</span>)</span><br><span class="line"><span class="comment">// 在数组中新增元素</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">2</span></span><br></pre></td></tr></table></div></figure>
</li>
<li>  不需要时将其内存释放<br>高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。</li>
</ul>

        <h1 id="垃圾回收机制"   >
          <a href="#垃圾回收机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1>
      <p>JS具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。</p>

        <h2 id="标记清除"   >
          <a href="#标记清除" class="heading-link"><i class="fas fa-link"></i></a><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2>
      <p>JS中最常见的垃圾回收方式是标记清除。</p>
<p>工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</p>
<p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”，也可以叫做”可达性”。</p>

        <h3 id="可达性"   >
          <a href="#可达性" class="heading-link"><i class="fas fa-link"></i></a><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h3>
      <p>“可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。其他不可达性的值被认为是垃圾被回收作为操作系统内存池的一部分。</p>
<p><strong>根</strong><br>有些可达性是固有的，比如<strong>全局变量，本地函数的局部变量和参数，当前嵌套调用链上的其他函数变量和参数</strong>。这些称为根，如果一个变量从“根”部不可达，那么就会被回收。</p>
<p><strong>可达对象的标记</strong><br>垃圾回收器会从根对象开始遍历。每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象。</p>
<p><strong>栈内存和堆内存</strong><br>内存管理分为栈内存和堆内存。栈内存的变量一般都是大小可知，有范围上限，存储js中简单的数据类型。堆内存是存放大小不固定，可以动态增加的变量，存储js中复杂数据类型——object，也是引用类型。</p>
<p>在运行时基本数据类型放入栈区，引用类型的值放入堆区，引用类型的地址存放在栈中(指针)，指向堆中引用类型的值。</p>
<p><img src="/images/post_img/GC/screenshot.png"></p>
<p>下面指一个例子</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj =  &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure>
<p>该obj是全局对象的一个变量，它存放在栈内存中，指向堆内存中为<code>&#123; a: 1 &#125;</code>的对象，因此该对象从根部为可达的，它为可达对象。</p>
<p>假如我们通过<code>obj = null</code>,这时候堆内存中为<code>&#123; a: 1 &#125;</code>的对象，就没有了可达性，因此它会被回收。</p>
<p>假如我们通过<code>var object = obj</code>,让object变量也指向该对象，这叫引用的拷贝(基本对象的拷贝是值的拷贝)，拷贝的是引用对象的地址。</p>
<p><img src="/images/post_img/GC/screenshot1.png"></p>
<p>紧接着，继续通过<code>obj = null</code>，这时候堆内存中为<code>&#123; a: 1 &#125;</code>的对象仍是可达的，因为它被一个叫object的变量所引用，所以仍然在系统内存中不会被回收。</p>
<p><img src="/images/post_img/GC/screenshot2.png"></p>
<p>接着让我们看一个相互引用的经典例子:</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFamily</span>(<span class="params">mother, father</span>) </span>&#123;</span><br><span class="line">  mon.husband = father</span><br><span class="line">  father.wife = mon</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    father,</span><br><span class="line">    mother      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> family = createFamily(&#123;</span><br><span class="line">    name: <span class="string">&#x27;John&#x27;</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">    name: <span class="string">&#x27;Ann&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure>
<p>上面的创建的family对象里面，两个子对象存在相互引用的情况，其中产生的内存结构如下：<br><img src="/images/post_img/GC/screenshot3.png"></p>
<p>现在，所有对象都是可访问的。</p>
<p>然后我们删除两个引用:</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> family.father;</span><br><span class="line"><span class="keyword">delete</span> family.mother.husband;</span><br></pre></td></tr></table></div></figure>
<p><img src="/images/post_img/GC/screenshot4.png"></p>
<p>此时对象的栈结构变成这样，father对象变得不再有引用，即不可达，因此会被回收。</p>
<p><img src="/images/post_img/GC/screenshot5.png"></p>
<p><img src="/images/post_img/GC/screenshot6.png"></p>
<p>假如我们仅删除这两个的其中一个引用，那么father对象仍是可达的，不会被垃圾回收器回收。</p>
<p>当然，我们可以使用<code>family = null</code>从”根”直接切断整个对象的引用，使得整个”family”对象不可达，能够被回收。<br><img src="/images/post_img/GC/screenshot7.png"></p>

        <h3 id="标记-清除步骤"   >
          <a href="#标记-清除步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#标记-清除步骤" class="headerlink" title="标记-清除步骤"></a>标记-清除步骤</h3>
      <p>垃圾回收器会定期执行一次垃圾回收，它的步骤如下：</p>
<ul>
<li>标记阶段<ul>
<li>  获取”根”对象并标记它们</li>
<li>  从”根”对象开始遍历，获取”根”对象引用的对象并标记它们，直至没有对象能够被访问到。</li>
</ul>
</li>
<li>清除阶段<ul>
<li><p>  从堆内存从头到尾进行线性遍历</p>
</li>
<li><p>发现没有被标记的对象，将对象占用的内存回收</p>
<p>⚠️通常来说，在使用标记清除算法时，未引用对象并不会被立即回收。取而代之的做法是，垃圾对象将一直累计到内存耗尽为止。<strong>当内存耗尽时，程序将会被挂起，垃圾回收开始执行。</strong></p>
</li>
</ul>
</li>
</ul>

        <h2 id="引用计数"   >
          <a href="#引用计数" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2>
      <p>这是最初级的垃圾收集算法.现在已经没有浏览器会用这种算法.</p>
<p>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> object = obj</span><br><span class="line"><span class="comment">// &#123;a: 1&#125;的引用次数为2</span></span><br><span class="line"></span><br><span class="line">obj = <span class="number">1</span></span><br><span class="line"><span class="comment">// &#123;a: 1&#125;的引用次数减少为1</span></span><br></pre></td></tr></table></div></figure>
<p>但是引用计数的缺点也十分明显，但两个对象进行循环引用时，它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。</p>
<p>然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/02/23/js%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5/">js中的同步和异步</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">创建时间</span><span class="post-meta-item__value">2021-02-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新时间</span><span class="post-meta-item__value">2021-02-23</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">0</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时间</span><span class="post-meta-item__value">1m</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/02/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/">浏览器内核及运行机制</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">创建时间</span><span class="post-meta-item__value">2021-02-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新时间</span><span class="post-meta-item__value">2021-02-25</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">2.9k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时间</span><span class="post-meta-item__value">15m</span></span></div></header><div class="post-body"><div class="post-excerpt">浏览器内核可以说是整个网页的重中之重了，整个网页的资源解析、脚本执行、界面渲染、事件处理等，都需要依靠浏览器的内核来执行。本篇文章我们就通过浏览器的进程和线程入手，再到具体的渲染过程。</div><div class="post-readmore"><a class="post-readmore__link" href="/2021/02/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"><span class="post-readmore__text">Read More</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/author-avatar.jpeg" alt="avatar"></div><p class="sidebar-ov-author__text">因上努力 果上随缘</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">21</div><div class="sidebar-ov-state-item__name">文章</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">5</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Ivan</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v5.3.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>